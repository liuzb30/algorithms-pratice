## 数据结构之----哈夫曼树

### 概念

#### 1.1 路径长度

`路径`：从一个节点到另一个节点之间的分支构成这两点之间的路径

`路径长度`：路径上的分支条数，树的路径长度是从树的根节点到每个节点的路径长度之和

#### 1.2 带权路径长度

`扩充二叉树`：每个叶节点有对应的权值的二叉树。
`带权路径长度`: 路径长度和该节点的权值的乘积。
`哈夫曼树`：带权路径长度最小的二叉树就是哈夫曼树，节点权值越大，距离根节点就越近

#### 1.3 哈夫曼算法

哈夫曼算法是构造权值集合为 { w1, ... wn } 的哈夫曼树，其算法思路如下

1.根据给定的 n 个权值 { w1, ... wn }， 构造具有 n 棵扩充二叉树的森林 F = { T1, ... Tn}, 对于每棵扩充二叉树 Ti 只有一个带权值的 wi 的根节点，左右子树都为空

2.重复以下步骤，直到 F 中只剩下一棵树为止

- 在 F 中选取两棵根节点的权值最小的扩充二叉树，把这两棵树作为左右子树构造一棵新的二叉树，这个新的二叉树的根节点的权值为其左右两棵子树根节点的权值之和
- 在 F 中删除第一步中选取的两棵二叉树
- 将第一步中构造的新的二叉树加入到 F 中

最后得到的就是哈夫曼树

### 2. 哈夫曼编码

在通信领域，经过哈夫曼编码的的信息小于大量冗余数据，提高传输效率，是重要的数据压缩方法。

## 数据结构之----二叉搜索树

### 1.概念

二叉搜索树具有一下四点性质：

- 所有节点关键码都互不相同
- 左子树上所有节点的关键码都小于根节点的关键码
- 右子树上所有节点的关键码都大于根节点的关键码
- 左右子树也是二叉搜索树

对二叉搜索树进行中序遍历，就可以按照关键码的大小从小到大的顺序将各节点排列起来，因此，二叉搜索树也叫二叉排序树

### 2.实现

#### 2.1 插入

插入时，从根节点开始，被插入元素的关键码如果比根节点关键码小，则进入到左子树中执行插入操作，如果左子树不存在，则被插入元素成为左孩子；反之，进入到右子树中执行插入操作，如果右子树不存在，则被插入元素成为右孩子，如果被插入元素的关键码已经存在，则返回 false。

#### 2.2 搜索

与插入算法非常接近，仍然是从树的根节点开始，如果被搜索元素的关键码比根节点关键码小，则进入到左子树中进行搜索，若左子树不存在，返回 null，如果被搜索元素的关键码比根节点关键码大，则进入到右子树中进行搜索，若右子树不存在，返回 null,如果根节点的关键码和被搜索元素的关键码相同，返回这个根节点。

#### 2.3 删除

删除一个节点时，要考虑到必须将被删除节点的子孙节点连接到树上，同时保证二叉搜索树的性质。

根据被删除节点的左右子孩子，可以总结一下几种情况：

- 被删除节点左右孩子都不存在
- 被删除节点没有右孩子
- 被删除节点没有左孩子
- 被删除节点左右孩子都存在

对于第 1 种情况，最为简单，只需要让其父节点指向它的指针指向 null 即可
对于第 2 种情况，用左孩子替代它的位置
对于第 3 种情况，用右孩子替代他的位置
对于第 4 中情况，稍稍有些复杂，首先，去被删除节点的右子树中找到中序遍历下的第一个节点，假设节点的 data 数据为 x，将被删除节点的 data 替换成 x，而后，在被删除节点的右子树中执行删除 x 的操作

## 数据结构之----平衡二叉树(AVL 树)

AVL 树首先是一棵二叉搜索树，但它具备自平衡的能力，它的左右子树都是 AVL 树，且左右子树的高度差的绝对值不超过 1。

#### 插入时的平衡化旋转

对于一棵 AVL 树，它的任意一个节点的平衡因子都只能取 -1， 0， 1 中的一个，如果节点的平衡因子绝对值大于 1，则 AVL 数失去了平衡性。

有四种平衡旋转方式使其重新平衡:

- 左单旋转
- 右单旋转
- 先左后右双旋转
- 先右后左双旋转

#### 删除时的平衡化处理

AVL 树在删除的时候，其操作方式和二叉搜索树是一样的，不同的地方在于，由于删除了一个节点，它的 parent 的平衡因子会发生变化，不止是被删除节点的 paren 它的平衡因子会发生变化，这个被删除节点的所有祖先节点的平衡因子都可能发生变化。

如果只观察被删除节点的 parent 的平衡因子的变化情况，有三种情况需要考虑

- parent 平衡因子从 0 变成 1 或者-1
- parent 平衡因子从-1 或 1 变成 0
- parent 平衡因子从 1 变成 2 或者从-1 变成-2

## 数据结构之----并查集

### 1.概念

并查集是一种非常简单但是非常有效的集合，它支持下面 3 种操作：

- union(root1, root2) 把集合 root2 合并入集合 root1 中，要求是 root1 和 root2 互不相交
- find(x) 搜索 x 所在的集合，返回该集合的名字
- 初始化函数， 将 s 个元素初始化为 s 个只有一个元素的子集合
  如果集合中有 n 个元素，可以用一个 0~n-1 个整数来表示这些元素，这个整数就是集合名，
  并查集的典型实现是采用数组，并用树形结构来表示元素及其所属子集的关系，回想一下堆，堆就是用数组来表达树结构，并查集是相同的道理，数组元素的索引就是这些元素的编号。

### 2.实现

#### 2.1 初始化

进行初始化的时候，数组里的每个元素都初始化为-1，这里有 3 个概念非常重要

- 每个元素都是一个单独的集合，与其他集合互不相交
- 对于刚刚初始化结束的并查集，每个元素是一个单独的集合，它的索引就是这个集合的集合名
- 每个元素的值，就是其父节点所在的索引，由于刚刚初始化，每个元素的值都是-1，-1 这个索引在数组中是不存在的，这恰好表明每个元素都没有父节点

#### 2.2 find

从 2.1 可以知道，待查找的值其实就是数组的索引，通过该索引的值就能找到它的父节点，通过父节点一层层往上查找就能找到待查找的值所在的集合。

#### 2.3 union

合并两个不相交的集合，比如 a 和 b，我们要让 a 是 b 的父节点，那么就把 b 的值设为 a 的索引。

### 3.应用（朋友圈问题）

有一个集合{0,1,2,3,4,5,6,7,8,9},共有 9 个元素，分别代表了 1 个人的编号，他们中有些人是朋友，下面的数组表达了这些人的朋友关系

```
var friends = [
    [0, 7],
    [1, 6],
    [4, 8],
    [8, 2],
    [9, 0],
    [3, 5],
    [1, 2]
];
```

## 数据结构之----散列表

散列表是表示集合，字典的另一种有效方法，它将关键码映射到某个位置上来存储元素，取值的时候，根据关键码找到对应的位置来取值。

### 1. 散列方法

散列表使用数组实现，如果关键码和索引之间有个映射关系，那么就可以通过 key 找到对应的索引，利用索引操作数组元素的时间负责度是 O(1)。
会面临两个问题：

- 数组中的索引是数字，但是关键码有可能是字符串
- 数组中的索引是连续的，关键码即使都是整数，也有可能超出索引范围

#### 1.1 hash 函数

hash，一般翻译成散列，音译是哈希，它把任意长度的输入，通过散列算法变换成固定长度的输出，这个输出结果就是散列值。
给 hash 函数一个字符串，它返回给你一个整数，这样，就解决了关键码不是整数的问题，不同的 key，可能会得到相同的 address，这种冲突的是不可避免的，好的 hash 算法，散列均匀，计算速度快。

#### 1.2 除留余数法

1.1 中解决了关键码不是整数的问题，关键码由非整数，变成了整数。但是还面临着关键码比数组索引大的问题，这时，可以使用除留余数法，假设数组大小为 m,则找一个最接近 m 或者等于 m 的质数 p 作为除数，那么求数组索引的方法便是 hash(key) = key % p
质数，能最大程度上避免冲突。

### 2.处理冲突

你给 hash 函数两个不同的字符串，它却返回了相同的结果，当然这个概率非常非常的低，真正的冲突不是 hash 函数造成的，而是除留余数法导致的。

处理冲突最有效的办法是采用开散列方法，数组中的索引只能存储一个值，如果这个值是链表，链表是可以存储多个值的。这样，就解决了冲突的问题，通过关键码找到数组索引，得到数组里存放的链表，然后通过这个链表来操作数据，需要注意的是，关键码也要做为数据存放到链表的节点上，这样才能实现查找和赋值，使用开散列发得到的链表结构。

### 3.实现

### 4.性能优化

当存储的 key 逐渐增加时，还是带来了新的问题，当每个链表储存的节点比较多时，每次查询或修改都要进行多次比较，这样，hashTable 的性能就会下降

为了解决性能问题，可以采用两种方法

- 使用搜索树
- 扩容

#### 扩容

HashTable 内部存储了存入 key 的数量，如果这个数量达到了除数的 5 倍（具体多少倍你可以自己定），那么我们就认为这个 HashTable 太拥挤了，需要扩大一下空间。用一个临时数组保存 items 的内容，然后将 items 扩大为原来的 2 倍，将临时数组里的保存的数据，重新分配到 items 中。
